/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_sandbox___ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__components_conditional_logic___ = __webpack_require__(2);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var __ = wp.i18n.__;
var _wp$blocks = wp.blocks,
    registerBlockType = _wp$blocks.registerBlockType,
    BlockDescription = _wp$blocks.BlockDescription;

var el = wp.element.createElement;
var _wp$blocks$InspectorC = wp.blocks.InspectorControls,
    SelectControl = _wp$blocks$InspectorC.SelectControl,
    RadioControl = _wp$blocks$InspectorC.RadioControl,
    TextControl = _wp$blocks$InspectorC.TextControl,
    ToggleControl = _wp$blocks$InspectorC.ToggleControl;

var InspectorControls = wp.blocks.InspectorControls;
var _wp$components = wp.components,
    Button = _wp$components.Button,
    Dashicon = _wp$components.Dashicon,
    IconButton = _wp$components.IconButton,
    PanelBody = _wp$components.PanelBody,
    Placeholder = _wp$components.Placeholder,
    Popover = _wp$components.Popover,
    Spinner = _wp$components.Spinner;

var Component = wp.element.Component;


// import ConditionalLogic from './components/conditional-logic/'


registerBlockType('gravityforms/block', {

	title: 'Gravity Forms',
	icon: function icon() {
		return React.createElement('img', { src: gform.icon, height: '20' });
	},
	category: 'embed',
	supports: {
		customClassName: false,
		className: false
	},
	supportHTML: false,
	attributes: {
		formId: {
			type: 'integer'
		},
		title: {
			type: 'bool',
			default: true
		},
		description: {
			type: 'bool',
			default: true
		},
		ajax: {
			type: 'bool',
			default: false
		},
		conditionalLogic: {
			type: 'object',
			default: {
				enabled: false,
				actionType: 'show',
				logicType: 'all',
				rules: [{}, {}]
			}
		},
		tabindex: {
			type: 'integer'
		},
		formPreview: {
			type: 'bool',
			default: true
		}
	},

	edit: function (_Component) {
		_inherits(edit, _Component);

		function edit() {
			_classCallCheck(this, edit);

			var _this = _possibleConstructorReturn(this, (edit.__proto__ || Object.getPrototypeOf(edit)).apply(this, arguments));

			_this.setFormId = _this.setFormId.bind(_this);
			_this.updateFormPreview = _this.updateFormPreview.bind(_this);

			_this.state = {
				html: '',
				fetching: false
			};

			return _this;
		}

		_createClass(edit, [{
			key: 'componentWillMount',
			value: function componentWillMount() {

				if (this.props.attributes.formId && this.props.attributes.formPreview) {
					this.setState({ fetching: true });
					this.updateFormPreview(this.props.attributes);
				}
			}
		}, {
			key: 'componentWillReceiveProps',
			value: function componentWillReceiveProps(props) {

				var oldAtts = this.props.attributes,
				    newAtts = props.attributes;

				if (oldAtts.formId === newAtts.formId && oldAtts.title === newAtts.title && oldAtts.description === newAtts.description && oldAtts.formPreview === newAtts.formPreview) {
					return;
				}

				if (!props.attributes.formId) {
					this.setState({ html: '' });
					return;
				}

				this.updateFormPreview(props.attributes);
			}
		}, {
			key: 'componentWillUnmount',
			value: function componentWillUnmount() {

				this.unmounting = true;
			}
		}, {
			key: 'setFormId',
			value: function setFormId(formId) {

				this.props.setAttributes({ formId: formId });
			}
		}, {
			key: 'updateFormPreview',
			value: function updateFormPreview(attributes) {
				var _this2 = this;

				if (this.state.fetching || !attributes.formPreview) {
					return;
				}

				var formId = attributes.formId,
				    title = attributes.title,
				    description = attributes.description;

				var apiURL = wpApiSettings.root + 'gf/v2/block/preview?formId=' + formId + '&title=' + (title ? title : false) + '&description=' + (description ? description : false);

				this.setState({ fetching: true });

				window.fetch(apiURL).then(function (response) {

					if (_this2.unmounting) {
						return;
					}

					response.json().then(function (obj) {

						if (obj.success) {
							_this2.setState({ html: obj.data.html });
						} else {
							_this2.setState({ html: '<p>' + __('Could not load form.', 'gravityforms') + '</p>' });
						}

						_this2.setState({ fetching: false });
					});
				});
			}
		}, {
			key: 'render',
			value: function render() {
				var _this3 = this;

				var _state = this.state,
				    html = _state.html,
				    fetching = _state.fetching;
				var _props$attributes = this.props.attributes,
				    formId = _props$attributes.formId,
				    title = _props$attributes.title,
				    description = _props$attributes.description,
				    ajax = _props$attributes.ajax,
				    tabindex = _props$attributes.tabindex,
				    formPreview = _props$attributes.formPreview,
				    conditionalLogic = _props$attributes.conditionalLogic;
				var _props = this.props,
				    setAttributes = _props.setAttributes,
				    focus = _props.focus,
				    setFocus = _props.setFocus;


				var toggleTitle = function toggleTitle() {
					return setAttributes({ title: !title });
				};
				var toggleDescription = function toggleDescription() {
					return setAttributes({ description: !description });
				};
				var toggleAjax = function toggleAjax() {
					return setAttributes({ ajax: !ajax });
				};
				var toggleFormPreview = function toggleFormPreview() {
					return setAttributes({ formPreview: !formPreview });
				};
				var toggleConditionalLogic = function toggleConditionalLogic() {
					return setAttributes({ conditionalLogic: { enabled: !conditionalLogic.enabled } });
				};

				var updateTabindex = function updateTabindex(tabindex) {
					return setAttributes({ tabindex: tabindex });
				};
				var updateConditionalLogic = function updateConditionalLogic(newLogic) {
					//let newLogic = Object.assign( conditionalLogic, logic );
					setAttributes({ conditionalLogic: newLogic });
				};

				var setFormIdFromPlaceholder = function setFormIdFromPlaceholder(e) {
					return _this3.setFormId(e.target.value);
				};

				var controls = [focus && React.createElement(
					InspectorControls,
					{ key: 'inspector' },
					React.createElement(
						BlockDescription,
						null,
						React.createElement(
							'p',
							null,
							'Gravity Forms'
						)
					),
					React.createElement(SelectControl, {
						label: __('Form', 'gravityforms'),
						value: formId,
						options: gform.forms,
						onChange: this.setFormId
					}),
					React.createElement(ToggleControl, {
						label: __('Form Title', 'gravityforms'),
						checked: title,
						onChange: toggleTitle
					}),
					React.createElement(ToggleControl, {
						label: __('Form Description', 'gravityforms'),
						checked: description,
						onChange: toggleDescription
					}),
					React.createElement(
						PanelBody,
						{ title: __('Conditional Logic', 'gravityforms'), className: 'gform-block-panel' },
						React.createElement(ToggleControl, {
							label: __('Conditional Logic', 'gravityforms'),
							checked: conditionalLogic.enabled,
							onChange: toggleConditionalLogic
						})
					),
					React.createElement(
						PanelBody,
						{ title: __('Advanced Settings', 'gravityforms'), initialOpen: false,
							className: 'gform-block-panel' },
						React.createElement(ToggleControl, {
							label: __('Preview', 'gravityforms'),
							checked: formPreview,
							onChange: toggleFormPreview
						}),
						React.createElement(ToggleControl, {
							label: __('AJAX', 'gravityforms'),
							checked: ajax,
							onChange: toggleAjax
						}),
						React.createElement(TextControl, {
							label: __('Tabindex', 'gravityforms'),
							value: tabindex,
							onChange: updateTabindex,
							placeholder: '-1'
						})
					)
				)];

				if (fetching) {
					return [controls, React.createElement(
						'div',
						{ key: 'loading', className: 'wp-block-embed is-loading' },
						React.createElement(Spinner, null),
						React.createElement(
							'p',
							null,
							__('Loading form preview...', 'gravityforms')
						)
					)];
				}

				if (!html || !formPreview) {

					return [controls, React.createElement(
						Placeholder,
						{ key: 'placeholder', className: 'wp-block-embed gform-block-placeholder' },
						React.createElement(
							'div',
							{ className: 'gform-block-placeholder-brand' },
							React.createElement('img', { src: gform.icon, width: '110' }),
							React.createElement(
								'p',
								null,
								React.createElement(
									'strong',
									null,
									'Gravity Forms'
								)
							)
						),
						React.createElement(
							'form',
							null,
							React.createElement(
								'select',
								{ value: formId, onChange: setFormIdFromPlaceholder },
								gform.forms.map(function (form) {
									return React.createElement(
										'option',
										{ key: form.value, value: form.value },
										form.label
									);
								})
							)
						)
					)];
				}

				return [controls, React.createElement(
					'div',
					{ className: 'wp-block-embed__wrapper' },
					React.createElement(__WEBPACK_IMPORTED_MODULE_0__components_sandbox___["a" /* default */], { html: html, onFocus: function onFocus() {
							return setFocus();
						} })
				)];
			}
		}]);

		return edit;
	}(Component),

	save: function save() {
		return null;
	}

});

/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Component = wp.element.Component;

var Sandbox = function (_Component) {
	_inherits(Sandbox, _Component);

	function Sandbox() {
		_classCallCheck(this, Sandbox);

		var _this = _possibleConstructorReturn(this, (Sandbox.__proto__ || Object.getPrototypeOf(Sandbox)).apply(this, arguments));

		_this.trySandbox = _this.trySandbox.bind(_this);
		_this.checkMessageForResize = _this.checkMessageForResize.bind(_this);
		_this.checkFocus = _this.checkFocus.bind(_this);

		_this.state = {
			width: 0,
			height: 0
		};
		return _this;
	}

	_createClass(Sandbox, [{
		key: 'isFrameAccessible',
		value: function isFrameAccessible() {
			try {
				return !!this.iframe.contentDocument.body;
			} catch (e) {
				return false;
			}
		}
	}, {
		key: 'checkMessageForResize',
		value: function checkMessageForResize(event) {
			var iframe = this.iframe;

			// Attempt to parse the message data as JSON if passed as string
			var data = event.data || {};
			if ('string' === typeof data) {
				try {
					data = JSON.parse(data);
				} catch (e) {} // eslint-disable-line no-empty
			}

			// Verify that the mounted element is the source of the message
			if (!iframe || iframe.contentWindow !== event.source) {
				return;
			}

			// Update the state only if the message is formatted as we expect, i.e.
			// as an object with a 'resize' action, width, and height
			var _data = data,
			    action = _data.action,
			    width = _data.width,
			    height = _data.height;
			var _state = this.state,
			    oldWidth = _state.width,
			    oldHeight = _state.height;


			if ('resize' === action && (oldWidth !== width || oldHeight !== height)) {
				this.setState({ width: width, height: height });
			}
		}
	}, {
		key: 'componentDidMount',
		value: function componentDidMount() {
			window.addEventListener('message', this.checkMessageForResize, false);
			window.addEventListener('blur', this.checkFocus);
			this.trySandbox();
		}
	}, {
		key: 'componentDidUpdate',
		value: function componentDidUpdate() {
			this.trySandbox();
		}
	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			window.removeEventListener('message', this.checkMessageForResize);
			window.removeEventListener('blur', this.checkFocus);
		}
	}, {
		key: 'checkFocus',
		value: function checkFocus() {
			if (this.props.onFocus && document.activeElement === this.iframe) {
				this.props.onFocus();
			}
		}
	}, {
		key: 'trySandbox',
		value: function trySandbox() {
			if (!this.isFrameAccessible()) {
				return;
			}

			var body = this.iframe.contentDocument.body;
			if (null !== body.getAttribute('data-resizable-iframe-connected')) {
				return;
			}

			// writing the document like this makes it act in the same way as if it was
			// loaded over the network, so DOM creation and mutation, script execution, etc.
			// all work as expected
			this.iframe.contentWindow.document.open();
			this.iframe.contentWindow.document.write(this.props.html);
			this.iframe.contentWindow.document.close();
		}
	}, {
		key: 'render',
		value: function render() {
			var _this2 = this;

			return React.createElement('iframe', {
				ref: function ref(node) {
					return _this2.iframe = node;
				},
				title: this.props.title,
				scrolling: 'no',
				sandbox: 'allow-scripts allow-same-origin allow-presentation',
				onLoad: this.trySandbox,
				width: Math.ceil(this.state.width),
				height: Math.ceil(this.state.height),
				style: { pointerEvents: 'none' } });
		}
	}], [{
		key: 'defaultProps',
		get: function get() {
			return {
				html: '',
				title: ''
			};
		}
	}]);

	return Sandbox;
}(Component);

/* harmony default export */ __webpack_exports__["a"] = (Sandbox);

/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ruleset___ = __webpack_require__(3);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var __ = wp.i18n.__;

var Component = wp.element.Component;
var _wp$components = wp.components,
    Button = _wp$components.Button,
    Popover = _wp$components.Popover;
var _wp$blocks$InspectorC = wp.blocks.InspectorControls,
    BaseControl = _wp$blocks$InspectorC.BaseControl,
    RadioControl = _wp$blocks$InspectorC.RadioControl;




var LogicControl = function (_Component) {
	_inherits(LogicControl, _Component);

	function LogicControl() {
		_classCallCheck(this, LogicControl);

		var _this = _possibleConstructorReturn(this, (LogicControl.__proto__ || Object.getPrototypeOf(LogicControl)).apply(this, arguments));

		_this.state = {
			visible: {
				actionType: false,
				logicType: false
			}
		};

		return _this;
	}

	_createClass(LogicControl, [{
		key: 'getActionTypes',
		value: function getActionTypes() {

			return [{
				label: __('Show', 'gravityforms'),
				value: 'show'
			}, {
				label: __('Hide', 'gravityforms'),
				value: 'hide'
			}];
		}
	}, {
		key: 'getActionTypeLabel',
		value: function getActionTypeLabel(actionType) {

			var actionTypes = this.getActionTypes();

			var targetAction = actionTypes.filter(function (action) {
				return action.value === actionType;
			});

			return targetAction[0].label;
		}
	}, {
		key: 'getLogicTypes',
		value: function getLogicTypes() {
			return [{
				label: __('all', 'gravityforms'),
				value: 'all'
			}, {
				label: __('any', 'gravityforms'),
				value: 'any'
			}];
		}
	}, {
		key: 'getLogicTypeLabel',
		value: function getLogicTypeLabel(logicType) {

			var logicTypes = this.getLogicTypes();

			var targetLogic = logicTypes.filter(function (logic) {
				return logic.value === logicType;
			});

			return targetLogic[0].label;
		}
	}, {
		key: 'render',
		value: function render() {
			var _this2 = this;

			var _props$value = this.props.value,
			    actionType = _props$value.actionType,
			    logicType = _props$value.logicType,
			    rules = _props$value.rules;


			actionType = 'show';
			logicType = 'all';

			var actionTypes = this.getActionTypes();
			var logicTypes = this.getLogicTypes();

			var toggleActionType = function toggleActionType() {
				return _this2.setState({ visible: { actionType: !_this2.state.visible.actionType } });
			};
			var toggleLogicType = function toggleLogicType() {
				return _this2.setState({ visible: { logicType: !_this2.state.visible.logicType } });
			};

			var changeActionType = function changeActionType(actionType) {
				return _this2.setState({
					logic: {
						actionType: actionType,
						logicType: _this2.state.logic.logicType
					}
				});
			};
			var changeLogicType = function changeLogicType(logicType) {
				return _this2.setState({
					logic: {
						actionType: _this2.state.logic.actionType,
						logicType: logicType
					}
				});
			};

			return React.createElement(
				'div',
				null,
				React.createElement(
					'div',
					{ className: 'gform-block-conditional-type' },
					React.createElement(
						Button,
						{ className: 'button-link', onClick: toggleActionType },
						React.createElement(
							'div',
							null,
							this.getActionTypeLabel(actionType)
						),
						React.createElement(
							Popover,
							{ isOpen: this.state.visible.actionType, onClose: toggleActionType, position: 'bottom', className: 'gform-block-conditional-popover' },
							React.createElement(RadioControl, { options: actionTypes, onChange: changeActionType, value: actionType })
						)
					),
					'\xA0form if\xA0',
					React.createElement(
						Button,
						{ className: 'button-link', onClick: toggleLogicType },
						React.createElement(
							'div',
							null,
							this.getLogicTypeLabel(logicType)
						),
						React.createElement(
							Popover,
							{ isOpen: this.state.visible.logicType, onClose: toggleLogicType, position: 'bottom', className: 'gform-block-conditional-popover' },
							React.createElement(RadioControl, { options: logicTypes, onChange: changeLogicType, value: logicType })
						)
					),
					'\xA0rules match',
					React.createElement(__WEBPACK_IMPORTED_MODULE_0__ruleset___["a" /* default */], { value: rules })
				)
			);
		}
	}]);

	return LogicControl;
}(Component);

/* unused harmony default export */ var _unused_webpack_default_export = (LogicControl);

/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__rule___ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_immutability_helper__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_immutability_helper___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_immutability_helper__);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var __ = wp.i18n.__;

var Component = wp.element.Component;
var IconButton = wp.components.IconButton;





var Ruleset = function (_Component) {
	_inherits(Ruleset, _Component);

	function Ruleset() {
		_classCallCheck(this, Ruleset);

		var _this = _possibleConstructorReturn(this, (Ruleset.__proto__ || Object.getPrototypeOf(Ruleset)).apply(this, arguments));

		_this.addRule = _this.addRule.bind(_this);

		return _this;
	}

	_createClass(Ruleset, [{
		key: 'addRule',
		value: function addRule() {

			var rules = this.getRules(),
			    newRules = rules.splice(rules.length, 0, {});

			console.log(rules);
			console.log(newRules);

			this.setRules(newRules);
		}
	}, {
		key: 'deleteRule',
		value: function deleteRule(index) {

			var rules = this.getRules();
			var newRules = __WEBPACK_IMPORTED_MODULE_1_immutability_helper___default()(rules, { $splice: [[index, 1]] });

			this.setRules(newRules);
		}
	}, {
		key: 'getRules',
		value: function getRules() {

			return this.props.value;
		}
	}, {
		key: 'setRules',
		value: function setRules(rules) {

			this.props.value = rules;
		}
	}, {
		key: 'getOptions',
		value: function getOptions() {

			return [{
				key: {
					label: 'User',
					value: 'user'
				},
				operators: ['is', 'is not'],
				value: [{
					label: 'Logged In',
					value: 'logged-in'
				}, {
					label: 'Logged Out',
					value: 'logged-out'
				}, {
					label: 'Roles',
					choices: [{
						label: 'Administrator',
						value: 'administrator'
					}, {
						label: 'Editor',
						value: 'editor'
					}, {
						label: 'Contributor',
						value: 'contributor'
					}, {
						label: 'Subscriber',
						value: 'subscriber'
					}]
				}]
			}];
		}
	}, {
		key: 'render',
		value: function render() {

			console.log(this.props);

			var rules = this.getRules().map(function (rule) {
				return React.createElement(__WEBPACK_IMPORTED_MODULE_0__rule___["a" /* default */], null);
			});

			return [rules, React.createElement(IconButton, {
				icon: 'insert',
				label: __('Add Rule'),
				onClick: this.addRule,
				className: 'editor-inserter__toggle' })];
		}
	}]);

	return Ruleset;
}(Component);

/* harmony default export */ __webpack_exports__["a"] = (Ruleset);

/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Component = wp.element.Component;
var Dashicon = wp.components.Dashicon;

var Rule = function (_Component) {
	_inherits(Rule, _Component);

	function Rule() {
		_classCallCheck(this, Rule);

		return _possibleConstructorReturn(this, (Rule.__proto__ || Object.getPrototypeOf(Rule)).apply(this, arguments));
	}

	_createClass(Rule, [{
		key: "render",
		value: function render() {

			return React.createElement(
				"div",
				{ className: "gform-block__conditional-rule" },
				React.createElement(
					"div",
					{ className: "inputs" },
					React.createElement(
						"select",
						null,
						React.createElement(
							"option",
							null,
							"User"
						)
					),
					React.createElement(
						"select",
						null,
						React.createElement(
							"option",
							null,
							"is"
						),
						React.createElement(
							"option",
							null,
							"is not"
						)
					),
					React.createElement(
						"select",
						null,
						React.createElement(
							"option",
							null,
							"Logged In"
						),
						React.createElement(
							"option",
							null,
							"Logged Out"
						),
						React.createElement(
							"optgroup",
							{ label: "Roles" },
							React.createElement(
								"option",
								null,
								"Administrator"
							),
							React.createElement(
								"option",
								null,
								"Editor"
							),
							React.createElement(
								"option",
								null,
								"Subscriber"
							),
							React.createElement(
								"option",
								null,
								"Contributor"
							)
						)
					)
				),
				React.createElement(
					"div",
					{ className: "controls" },
					React.createElement(Dashicon, { icon: "trash" })
				)
			);
		}
	}]);

	return Rule;
}(Component);

/* harmony default export */ __webpack_exports__["a"] = (Rule);

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

var invariant = __webpack_require__(6);

var hasOwnProperty = Object.prototype.hasOwnProperty;
var splice = Array.prototype.splice;

var toString = Object.prototype.toString
var type = function(obj) {
  return toString.call(obj).slice(8, -1);
}

var assign = Object.assign || /* istanbul ignore next */ function assign(target, source) {
  getAllKeys(source).forEach(function(key) {
    if (hasOwnProperty.call(source, key)) {
      target[key] = source[key];
    }
  });
  return target;
};

var getAllKeys = typeof Object.getOwnPropertySymbols === 'function' ?
  function(obj) { return Object.keys(obj).concat(Object.getOwnPropertySymbols(obj)) } :
  /* istanbul ignore next */ function(obj) { return Object.keys(obj) };

/* istanbul ignore next */
function copy(object) {
  if (Array.isArray(object)) {
    return assign(object.constructor(object.length), object)
  } else if (type(object) === 'Map') {
    return new Map(object)
  } else if (type(object) === 'Set') {
    return new Set(object)
  } else if (object && typeof object === 'object') {
    var prototype = object.constructor && object.constructor.prototype
    return assign(Object.create(prototype || null), object);
  } else {
    return object;
  }
}

function newContext() {
  var commands = assign({}, defaultCommands);
  update.extend = function(directive, fn) {
    commands[directive] = fn;
  };
  update.isEquals = function(a, b) { return a === b; };

  return update;

  function update(object, spec) {
    if (typeof spec === 'function') {
      return spec(object);
    }

    if (!(Array.isArray(object) && Array.isArray(spec))) {
      invariant(
        !Array.isArray(spec),
        'update(): You provided an invalid spec to update(). The spec may ' +
        'not contain an array except as the value of $set, $push, $unshift, ' +
        '$splice or any custom command allowing an array value.'
      );
    }

    invariant(
      typeof spec === 'object' && spec !== null,
      'update(): You provided an invalid spec to update(). The spec and ' +
      'every included key path must be plain objects containing one of the ' +
      'following commands: %s.',
      Object.keys(commands).join(', ')
    );

    var nextObject = object;
    var index, key;
    getAllKeys(spec).forEach(function(key) {
      if (hasOwnProperty.call(commands, key)) {
        var objectWasNextObject = object === nextObject;
        nextObject = commands[key](spec[key], nextObject, spec, object);
        if (objectWasNextObject && update.isEquals(nextObject, object)) {
          nextObject = object;
        }
      } else {
        var nextValueForKey = update(object[key], spec[key]);
        if (!update.isEquals(nextValueForKey, nextObject[key]) || typeof nextValueForKey === 'undefined' && !hasOwnProperty.call(object, key)) {
          if (nextObject === object) {
            nextObject = copy(object);
          }
          nextObject[key] = nextValueForKey;
        }
      }
    })
    return nextObject;
  }

}

var defaultCommands = {
  $push: function(value, nextObject, spec) {
    invariantPushAndUnshift(nextObject, spec, '$push');
    return value.length ? nextObject.concat(value) : nextObject;
  },
  $unshift: function(value, nextObject, spec) {
    invariantPushAndUnshift(nextObject, spec, '$unshift');
    return value.length ? value.concat(nextObject) : nextObject;
  },
  $splice: function(value, nextObject, spec, originalObject) {
    invariantSplices(nextObject, spec);
    value.forEach(function(args) {
      invariantSplice(args);
      if (nextObject === originalObject && args.length) nextObject = copy(originalObject);
      splice.apply(nextObject, args);
    });
    return nextObject;
  },
  $set: function(value, nextObject, spec) {
    invariantSet(spec);
    return value;
  },
  $toggle: function(targets, nextObject) {
    invariantSpecArray(targets, '$toggle');
    var nextObjectCopy = targets.length ? copy(nextObject) : nextObject;

    targets.forEach(function(target) {
      nextObjectCopy[target] = !nextObject[target];
    });

    return nextObjectCopy;
  },
  $unset: function(value, nextObject, spec, originalObject) {
    invariantSpecArray(value, '$unset');
    value.forEach(function(key) {
      if (Object.hasOwnProperty.call(nextObject, key)) {
        if (nextObject === originalObject) nextObject = copy(originalObject);
        delete nextObject[key];
      }
    });
    return nextObject;
  },
  $add: function(value, nextObject, spec, originalObject) {
    invariantMapOrSet(nextObject, '$add');
    invariantSpecArray(value, '$add');
    if (type(nextObject) === 'Map') {
      value.forEach(function(pair) {
        var key = pair[0];
        var value = pair[1];
        if (nextObject === originalObject && nextObject.get(key) !== value) nextObject = copy(originalObject);
        nextObject.set(key, value);
      });
    } else {
      value.forEach(function(value) {
        if (nextObject === originalObject && !nextObject.has(value)) nextObject = copy(originalObject);
        nextObject.add(value);
      });
    }
    return nextObject;
  },
  $remove: function(value, nextObject, spec, originalObject) {
    invariantMapOrSet(nextObject, '$remove');
    invariantSpecArray(value, '$remove');
    value.forEach(function(key) {
      if (nextObject === originalObject && nextObject.has(key)) nextObject = copy(originalObject);
      nextObject.delete(key);
    });
    return nextObject;
  },
  $merge: function(value, nextObject, spec, originalObject) {
    invariantMerge(nextObject, value);
    getAllKeys(value).forEach(function(key) {
      if (value[key] !== nextObject[key]) {
        if (nextObject === originalObject) nextObject = copy(originalObject);
        nextObject[key] = value[key];
      }
    });
    return nextObject;
  },
  $apply: function(value, original) {
    invariantApply(value);
    return value(original);
  }
};

module.exports = newContext();
module.exports.newContext = newContext;

// invariants

function invariantPushAndUnshift(value, spec, command) {
  invariant(
    Array.isArray(value),
    'update(): expected target of %s to be an array; got %s.',
    command,
    value
  );
  invariantSpecArray(spec[command], command)
}

function invariantSpecArray(spec, command) {
  invariant(
    Array.isArray(spec),
    'update(): expected spec of %s to be an array; got %s. ' +
    'Did you forget to wrap your parameter in an array?',
    command,
    spec
  );
}

function invariantSplices(value, spec) {
  invariant(
    Array.isArray(value),
    'Expected $splice target to be an array; got %s',
    value
  );
  invariantSplice(spec['$splice']);
}

function invariantSplice(value) {
  invariant(
    Array.isArray(value),
    'update(): expected spec of $splice to be an array of arrays; got %s. ' +
    'Did you forget to wrap your parameters in an array?',
    value
  );
}

function invariantApply(fn) {
  invariant(
    typeof fn === 'function',
    'update(): expected spec of $apply to be a function; got %s.',
    fn
  );
}

function invariantSet(spec) {
  invariant(
    Object.keys(spec).length === 1,
    'Cannot have more than one key in an object with $set'
  );
}

function invariantMerge(target, specValue) {
  invariant(
    specValue && typeof specValue === 'object',
    'update(): $merge expects a spec of type \'object\'; got %s',
    specValue
  );
  invariant(
    target && typeof target === 'object',
    'update(): $merge expects a target of type \'object\'; got %s',
    target
  );
}

function invariantMapOrSet(target, command) {
  var typeOfTarget = type(target);
  invariant(
    typeOfTarget === 'Map' || typeOfTarget === 'Set',
    'update(): %s expects a target of type Set or Map; got %s',
    command,
    typeOfTarget
  );
}


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function(condition, format, a, b, c, d, e, f) {
  if (process.env.NODE_ENV !== 'production') {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        'Minified exception occurred; use the non-minified dev environment ' +
        'for the full error message and additional helpful warnings.'
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        format.replace(/%s/g, function() { return args[argIndex++]; })
      );
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ }),
/* 7 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ })
/******/ ]);